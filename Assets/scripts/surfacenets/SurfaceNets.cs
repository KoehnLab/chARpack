using IngameDebugConsole;
using UnityEngine;

public class SurfaceNets : MonoBehaviour
{
    public ComputeShader surfaceNetsShader;
    private int gridSizeX = 128; // X dimension of the grid
    private int gridSizeY = 128; // Y dimension of the grid
    private int gridSizeZ = 128; // Z dimension of the grid
    public float threshold = 0.5f; // Adjustable threshold for surface generation
    private Texture3D voxelFieldTexture;

    private ComputeBuffer verticesBuffer;
    private ComputeBuffer trianglesBuffer;
    private ComputeBuffer verticesCountBuffer;

    private int kernelHandle;

    private bool isInitialized = false;


    private void Start()
    {
        DebugLogConsole.AddCommand("testSurfaceNets", "runs a test for the surface nets algorithm", loadData);
    }

    void loadData()
    {
        //var path = "D:\\mol_data\\robert_a\\Pd_spin_vector_density.csv";
        
    }

    void Initialize()
    {
        // Set up the compute shader
        kernelHandle = surfaceNetsShader.FindKernel("CSMain");

        // Create buffers to hold the results
        verticesBuffer = new ComputeBuffer(1024 * 1024, sizeof(float) * 3); // 1M vertices max
        trianglesBuffer = new ComputeBuffer(1024 * 1024, sizeof(int) * 3);  // Adjust based on expected triangles
        verticesCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);  // Stores the number of vertices
        verticesCountBuffer.SetData(new int[] { 0 }); // Initialize to zero

        // Set up the voxel field as a 3D texture
        surfaceNetsShader.SetTexture(kernelHandle, "voxelField", voxelFieldTexture);
        surfaceNetsShader.SetBuffer(kernelHandle, "vertices", verticesBuffer);
        surfaceNetsShader.SetBuffer(kernelHandle, "triangles", trianglesBuffer);

        // Set dynamic grid size and threshold as constants in the shader
        surfaceNetsShader.SetInt("gridSizeX", gridSizeX);
        surfaceNetsShader.SetInt("gridSizeY", gridSizeY);
        surfaceNetsShader.SetInt("gridSizeZ", gridSizeZ);
        surfaceNetsShader.SetFloat("threshold", threshold);

        // Dispatch the compute shader
        surfaceNetsShader.Dispatch(kernelHandle, gridSizeX / 8, gridSizeY / 8, gridSizeZ / 8);

        isInitialized = true;
    }

    void OnDestroy()
    {
        // Clean up buffers
        if (verticesBuffer != null)
            verticesBuffer.Release();
        if (trianglesBuffer != null)
            trianglesBuffer.Release();
        if (verticesCountBuffer != null)
            verticesCountBuffer.Release();
    }

    void Update()
    {
        if (!isInitialized) return;

        // Get the number of vertices generated by the compute shader
        int[] vertexCountArray = new int[1];
        verticesCountBuffer.GetData(vertexCountArray);
        int verticesCount = vertexCountArray[0];

        // Once the compute shader finishes, construct a mesh
        Vector3[] vertices = new Vector3[verticesCount];
        verticesBuffer.GetData(vertices);

        int[] triangles = new int[trianglesBuffer.count];
        trianglesBuffer.GetData(triangles);

        Mesh mesh = new Mesh();
        mesh.vertices = vertices;
        mesh.triangles = triangles;

        // Optionally add normals, UVs, etc.
        mesh.RecalculateNormals();

        // Create a new GameObject and assign the mesh
        MeshFilter meshFilter = GetComponent<MeshFilter>();
        if (meshFilter == null)
        {
            meshFilter = gameObject.AddComponent<MeshFilter>();
        }
        meshFilter.mesh = mesh;

        MeshRenderer meshRenderer = GetComponent<MeshRenderer>();
        if (meshRenderer == null)
        {
            meshRenderer = gameObject.AddComponent<MeshRenderer>();
        }
        meshRenderer.material = new Material(Shader.Find("Standard"));
    }
}
